# -*- coding: utf-8 -*-
"""justin_callahan_midterm_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EH7YF-GvGT23DZyv-8owyLLn1q6hCF0w
"""

import pandas as pd
import numpy as np
from sklearn.svm import LinearSVR
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import KFold
from sklearn import linear_model
from sklearn.metrics import mean_squared_error
from math import sqrt
from sklearn.model_selection import train_test_split as tts
from sklearn.linear_model import Ridge, Lasso, ElasticNet, LinearRegression
import operator
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.preprocessing import PolynomialFeatures

df = pd.read_csv ('weatherHistory.csv')

actual = df[['Temperature (C)']]
predicted = df[['Humidity']]
mse = mean_squared_error(actual, predicted)
rmse = sqrt(mse)
print(rmse)

from sklearn.preprocessing import StandardScaler
scale = StandardScaler()
from sklearn.model_selection import KFold # import KFold
kf = KFold(n_splits=10, random_state=2020, shuffle = True)

X_train, X_test, y_train, y_test = train_test_split(actual, predicted, random_state=2020)
Xs_train = scale.fit_transform(X_train)
Xs_test  = scale.transform(X_test)

model = Ridge(alpha=0.1)
model.fit(Xs_train, y_train)
yhat =  model.predict(Xs_test)
residuals = y_test - yhat

mse = mean_squared_error(y_test, yhat)
rmse = sqrt(mse)
print(rmse)

from sklearn.ensemble import RandomForestRegressor as RFR
x = df[['Humidity','Wind Speed (km/h)','Pressure (millibars)','Wind Bearing (degrees)']]
y = df[['Temperature (C)']]
Xtrain,Xtest,ytrain,ytest = tts(x, y, random_state=1693)

rfr = RFR(random_state=1693, n_estimators=100, max_depth=50)
rfr.fit(Xtrain,ytrain)

y_pred = rfr.predict(Xtest)
mse = mean_squared_error(y_test, y_pred)
rmse = sqrt(mse)
print(rmse)

x = df[['Humidity','Wind Speed (km/h)','Pressure (millibars)','Wind Bearing (degrees)']]
y= df['Temperature (C)']
xx= x.values
polynomial_features= PolynomialFeatures(degree=6)
x_poly = polynomial_features.fit_transform(xx)
df_poly = pd.DataFrame(data=x_poly)
df_poly

model = LinearRegression()
model.fit(x_poly, y.values)
y_poly_pred = model.predict(x_poly)
rmse = np.sqrt(mean_squared_error(y,y_poly_pred))
rmse

X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=2021)
Xs_train = scale.fit_transform(X_train)
Xs_test  = scale.transform(X_test)

def DoKFold(model,X,y,k,random_state=1234,scaler=None):
    '''Function will perform K-fold validation and return a list of K training and testing scores, inclduing R^2 as well as MSE.
    
        Inputs:
            model: An sklearn model with defined 'fit' and 'score' methods
            X: An N by p array containing the features of the model. The N rows are observations, and the p columns are features.
            y: An array of length N containing the target of the model
            k: The number of folds to split the data into for K-fold validation
            random_state: used when splitting the data into the K folds (default=146)
            scaler: An sklearn feature scaler.  If none is passed, no feature scaling will be performed
        Outputs:
            train_scores: A list of length K containing the training scores
            test_scores: A list of length K containing the testing scores
            train_mse: A list of length K containing the MSE on training data
            test_mse: A list of length K containing the MSE on testing data
    '''
    
    from sklearn.model_selection import KFold
    kf = KFold(n_splits=k,shuffle=True,random_state=random_state)
    
    train_scores=[]
    test_scores=[]
    train_mse=[]
    test_mse=[]
    
    for idxTrain, idxTest in kf.split(X):
        Xtrain = X[idxTrain,:]
        Xtest = X[idxTest,:]
        ytrain = y[idxTrain]
        ytest = y[idxTest]
        
        if scaler != None:
            Xtrain = scaler.fit_transform(Xtrain)
            Xtest = scaler.transform(Xtest)
        
        model.fit(Xtrain,ytrain)
        
        train_scores.append(model.score(Xtrain,ytrain))
        test_scores.append(model.score(Xtest,ytest))
        
        # Compute the mean squared errors
        ytrain_pred = model.predict(Xtrain)
        ytest_pred = model.predict(Xtest)
        train_mse.append(np.mean((ytrain-ytrain_pred)**2))
        test_mse.append(np.mean((ytest-ytest_pred)**2))
        
    return train_scores,test_scores,train_mse,test_mse

x= df['Temperature (C)'].to_numpy()
y=df['Humidity'].to_numpy()
DoKFold(Ridge,x,y,10,random_state=1234,scaler=StandardScaler)